<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MNS Terminal</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #00ff66;
      font-family: "Courier New", monospace;
      height: 100%;
    }
    #terminal {
      box-sizing: border-box;
      padding: 16px;
      height: 100%;
      overflow-y: auto;
      white-space: pre;
    }
    #nav {
      position: sticky;
      top: 0;
      background: #000;
      border-bottom: 1px solid #00aa44;
      padding-bottom: 6px;
      margin-bottom: 10px;
      font-weight: bold;
    }
    .log {
      line-height: 1.3;
    }
  </style>
</head>
<body>
  <div id="terminal">
    <div id="nav"></div>
    <div id="logs"></div>
  </div>

  <script>
    /* =========================
       Phase 11.6 — Tier 0 Public Implementation
       ========================= */

    /* ---- Deterministic PRNG ---- */
    function seededRandom(seed) {
      let x = Math.sin(seed++) * 10000;
      return x - Math.floor(x);
    }

    let tick = 1;

    /* ---- Phase 11.6 Access Context (TIER 0 ONLY) ---- */
    const AccessContext = {
      current_view_tier: "TIER_0",
      last_valid_tier: "TIER_0"
    };

    /* ---- Phase 11.4 NAV State Machine (CANONICAL) ---- */
    const NAV_STATE = {
      regime: "ACCUMULATION",
      bias: "NEUTRAL",
      confidence: 0.5,
      sinceTick: 0
    };

    /* ---- Phase 11.3 Regime Taxonomy (IMMUTABLE) ---- */
    const REGIMES = {
      ACCUMULATION: "ACCUMULATION",
      EXPANSION: "EXPANSION",
      DISLOCATION: "DISLOCATION",
      EXHAUSTION: "EXHAUSTION",
      COMPRESSION: "COMPRESSION"
    };

    const BIAS = {
      BULLISH: "BULLISH",
      BEARISH: "BEARISH",
      NEUTRAL: "NEUTRAL"
    };

    /* ---- Phase 11.3 Transition Rules (IMMUTABLE) ---- */
    const FORBIDDEN_TRANSITIONS = {
      ACCUMULATION: [REGIMES.DISLOCATION, REGIMES.EXHAUSTION],
      EXPANSION: [REGIMES.ACCUMULATION, REGIMES.COMPRESSION],
      DISLOCATION: [REGIMES.ACCUMULATION, REGIMES.EXPANSION],
      EXHAUSTION: [REGIMES.ACCUMULATION, REGIMES.EXPANSION],
      COMPRESSION: [REGIMES.EXPANSION, REGIMES.DISLOCATION]
    };

    const MIN_HOLD_TIME = 3;

    /* ---- Global State ---- */
    const TunnelState = {
      phase: "11.6",
      status: "STABLE",
      location: "TBILISI_HUB_01",
      depth: 42,
      nodes: [
        { id: "TBILISI_01", load: 0.52, status: "STABLE" }
      ]
    };

    const MAX_LINES = 120;
    const logsEl = document.getElementById("logs");
    const navEl = document.getElementById("nav");

    /* ---- Phase 11.6 Sanitization Logic (MANDATORY) ---- */
    function sanitizeToTier0() {
      const terminal = document.getElementById("terminal");
      if (terminal) {
        logsEl.innerHTML = "";
        navEl.innerHTML = "";
      }

      NAV_STATE.regime = "UNKNOWN";
      NAV_STATE.bias = "NEUTRAL";
      NAV_STATE.confidence = 0.3;
      NAV_STATE.sinceTick = 0;

      TunnelState.depth = 50;
      TunnelState.nodes = [
        { id: "NODE_01", load: 0.5, status: "NOMINAL" }
      ];

      AccessContext.current_view_tier = "TIER_0";
      AccessContext.last_valid_tier = "TIER_0";
    }

    /* ---- Phase 11.6 Structure Gate (Silent Handshake Stub) ---- */
    function evaluateIncomingPacket(packet) {
      const tier0Fields = ["regime", "confidence"];
      const packetKeys = Object.keys(packet);

      for (const key of packetKeys) {
        if (key === "bias" || key === "sinceTick" || key === "drivers" || key === "blockers") {
          sanitizeToTier0();
          return null;
        }
      }

      return packet;
    }

    /* ---- Phase 11.6 Tier 0 Packet Sanitizer ---- */
    function sanitizePacketForTier0(rawPacket) {
      return {
        regime: rawPacket.regime || "UNKNOWN",
        confidence: rawPacket.confidence !== undefined ? rawPacket.confidence : 0.3
      };
    }

    /* ---- Input Snapshot Generation (Deterministic Emulator) ---- */
    function generateInputSnapshot() {
      const r1 = seededRandom(tick * 7);
      const r2 = seededRandom(tick * 13);
      const r3 = seededRandom(tick * 19);
      const r4 = seededRandom(tick * 23);
      const r5 = seededRandom(tick * 29);

      return {
        volatility_index: r1,
        liquidity_gap_score: r2,
        momentum_score: (r3 - 0.5) * 2,
        compression_score: r4,
        exhaustion_score: r5,
        timestamp: tick
      };
    }

    /* ---- Phase 11.4 Transition Evaluation Pipeline (STRICT ORDER) ---- */
    function evaluateTransition(snapshot) {
      const currentRegime = NAV_STATE.regime;
      const currentBias = NAV_STATE.bias;

      // Step a) Shock detection
      const isShock = snapshot.volatility_index > 0.90;
      
      // Step b) Regime candidate detection
      let candidateRegime = currentRegime;
      let candidateBias = currentBias;
      let candidateConfidence = NAV_STATE.confidence;

      if (isShock) {
        candidateRegime = REGIMES.DISLOCATION;
        candidateBias = snapshot.momentum_score > 0 ? BIAS.BEARISH : BIAS.BULLISH;
        candidateConfidence = 0.8;
      } else {
        // Normal regime detection logic
        if (snapshot.compression_score > 0.75) {
          candidateRegime = REGIMES.COMPRESSION;
          candidateConfidence = 0.7;
        } else if (snapshot.exhaustion_score > 0.80) {
          candidateRegime = REGIMES.EXHAUSTION;
          candidateConfidence = 0.75;
        } else if (snapshot.momentum_score > 0.6) {
          candidateRegime = REGIMES.EXPANSION;
          candidateBias = BIAS.BULLISH;
          candidateConfidence = 0.65;
        } else if (snapshot.momentum_score < -0.6) {
          candidateRegime = REGIMES.EXPANSION;
          candidateBias = BIAS.BEARISH;
          candidateConfidence = 0.65;
        } else if (snapshot.liquidity_gap_score < 0.3) {
          candidateRegime = REGIMES.ACCUMULATION;
          candidateBias = BIAS.NEUTRAL;
          candidateConfidence = 0.6;
        } else {
          // No clear signal, drift confidence down
          candidateConfidence = Math.max(0.3, NAV_STATE.confidence - 0.05);
        }
      }

      // If no regime change detected, return early
      if (candidateRegime === currentRegime) {
        // Update confidence only
        NAV_STATE.confidence = candidateConfidence;
        NAV_STATE.sinceTick++;
        return;
      }

      // Step c) Forbidden transition check
      const forbidden = FORBIDDEN_TRANSITIONS[currentRegime] || [];
      if (forbidden.includes(candidateRegime)) {
        // REJECT: forbidden transition
        NAV_STATE.sinceTick++;
        return;
      }

      // Step d) Min Hold Time check
      if (NAV_STATE.sinceTick < MIN_HOLD_TIME) {
        // REJECT: min hold time not satisfied
        NAV_STATE.sinceTick++;
        return;
      }

      // Step e) Bias drift constraint check
      if (candidateBias !== currentBias) {
        // Bias change requires NEUTRAL intermediate OR shock override
        if (currentBias !== BIAS.NEUTRAL && candidateBias !== BIAS.NEUTRAL && !isShock) {
          // REJECT: cannot flip bias directly without NEUTRAL
          NAV_STATE.sinceTick++;
          return;
        }
      }

      // Step f) State commit
      NAV_STATE.regime = candidateRegime;
      NAV_STATE.bias = candidateBias;
      NAV_STATE.confidence = candidateConfidence;
      NAV_STATE.sinceTick = 0;
    }

    /* ---- State Update Logic ---- */
    function updateState() {
      const r = seededRandom(tick);

      // Smooth bounded drift
      TunnelState.depth = Math.min(
        100,
        Math.max(0, TunnelState.depth + (r - 0.5) * 2)
      );

      TunnelState.nodes.forEach(n => {
        n.load = Math.min(1, Math.max(0, n.load + (r - 0.5) * 0.05));
      });

      // Generate input snapshot from emulator
      const snapshot = generateInputSnapshot();

      // Evaluate NAV state transition
      evaluateTransition(snapshot);
    }

    /* ---- Render Logic (Phase 11.6 Hardened) ---- */
    function renderNAV(safePacket) {
      try {
        const confidenceLabel =
          safePacket.confidence >= 0.7 ? "HIGH" :
          safePacket.confidence >= 0.4 ? "MEDIUM" :
          "LOW";

        navEl.textContent =
          `[NAV] REGIME: ${safePacket.regime}` +
          ` | CONFIDENCE: ${confidenceLabel}`;
      } catch (e) {
        sanitizeToTier0();
        navEl.textContent = `[NAV] REGIME: UNKNOWN | CONFIDENCE: LOW`;
      }
    }

    function renderTelemetry() {
      try {
        const barLen = 20;
        const filled = Math.round((TunnelState.depth / 100) * barLen);
        const bar =
          "█".repeat(filled) + "░".repeat(barLen - filled);

        const line =
          `[TELEMETRY] depth=[${bar}] ${TunnelState.depth.toFixed(0)}%` +
          ` | node:${TunnelState.nodes[0].id}` +
          ` load:${TunnelState.nodes[0].load.toFixed(2)}`;

        const div = document.createElement("div");
        div.className = "log";
        div.textContent = line;

        logsEl.appendChild(div);

        while (logsEl.children.length > MAX_LINES) {
          logsEl.removeChild(logsEl.firstChild);
        }

        logsEl.parentElement.scrollTop =
          logsEl.parentElement.scrollHeight;
      } catch (e) {
        sanitizeToTier0();
      }
    }

    function renderTick() {
      try {
        const rawPacket = {
          regime: NAV_STATE.regime,
          confidence: NAV_STATE.confidence,
          bias: NAV_STATE.bias,
          sinceTick: NAV_STATE.sinceTick
        };

        const validatedPacket = evaluateIncomingPacket(rawPacket);
        if (!validatedPacket) {
          return;
        }

        const safePacket = sanitizePacketForTier0(validatedPacket);
        renderNAV(safePacket);
        renderTelemetry();
      } catch (e) {
        sanitizeToTier0();
        renderNAV({ regime: "UNKNOWN", confidence: 0.3 });
      }
    }

    /* ---- Render Loop ---- */
    let renderInterval = null;

    function startRenderLoop() {
      renderInterval = setInterval(() => {
        tick++;
        updateState();
        renderTick();
      }, 900);
    }

    /* ---- Boot Sequence (Phase 11.6 Safe Default) ---- */
    (function init() {
      sanitizeToTier0();
      renderNAV({ regime: "UNKNOWN", confidence: 0.3 });
      
      setTimeout(() => {
        startRenderLoop();
      }, 100);
    })();
  </script>
</body>
</html>
