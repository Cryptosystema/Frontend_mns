<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MNS Terminal — mns.com.ge</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #00ff66;
      font-family: "Courier New", monospace;
      height: 100%;
      overflow: hidden;
    }
    #terminal {
      box-sizing: border-box;
      padding: 20px;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      white-space: pre;
    }
    #nav {
      font-weight: bold;
      margin-bottom: 8px;
      letter-spacing: 0.5px;
    }
    #status {
      opacity: 0.7;
      margin-bottom: 20px;
      letter-spacing: 0.5px;
      animation: heartbeat 4s ease-in-out infinite;
    }
    @keyframes heartbeat {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 0.85; }
    }
  </style>
</head>
<body>
  <div id="terminal">
    <div id="nav"></div>
    <div id="status"></div>
  </div>

  <script>
    /* =========================
       Phase 18.2 — Unified Validation Pipeline
       Market Navigation System (MNS)
       Target: mns.com.ge
       Mode: Protocol-Grade, Multi-Tier, Fail-Closed
       ========================= */

    "use strict";

    /* ---- CRYPTOGRAPHIC ANCHORS (IMMUTABLE) ---- */
    const TRUSTED_KEYS = Object.freeze({
      "key_001": "REPLACE_WITH_BASE64_44_CHARS_KEY1",
      "key_002": "REPLACE_WITH_BASE64_44_CHARS_KEY2"
    });
    const MAX_SKEW_MS = 30000;
    
    if (Object.keys(TRUSTED_KEYS).length > 2) {
      throw new Error("Invariant violation: max 2 trusted keys");
    }

    /* ---- TIER 0 STATIC NAV PACKET (IMMUTABLE) ---- */
    const STATIC_NAV_PACKET = Object.freeze({
      regime: "COMPRESSION",
      risk: "NORMAL",
      confidence: "MEDIUM",
      status: "LIVE",
      scope: "PUBLIC"
    });

    /* ---- REGIME CATALOG (IMMUTABLE) ---- */
    const REGIMES = Object.freeze([
      "ACCUMULATION",
      "EXPANSION",
      "DISLOCATION",
      "EXHAUSTION",
      "COMPRESSION"
    ]);

    /* ---- RISK LEVELS (IMMUTABLE) ---- */
    const RISK_LEVELS = Object.freeze([
      "LOW",
      "NORMAL",
      "HIGH"
    ]);

    /* ---- CONFIDENCE LEVELS (IMMUTABLE) ---- */
    const CONFIDENCE_LEVELS = Object.freeze([
      "LOW",
      "MEDIUM",
      "HIGH"
    ]);

    /* ---- BIAS LEVELS (TIER 1, IMMUTABLE) ---- */
    const BIAS_LEVELS = Object.freeze([
      "BULLISH",
      "BEARISH",
      "NEUTRAL"
    ]);

    /* ---- STABILITY LEVELS (TIER 1, IMMUTABLE) ---- */
    const STABILITY_LEVELS = Object.freeze([
      "FORMING",
      "MATURE",
      "WEAKENING"
    ]);

    /* ---- NAVIGATOR FIELDS (TIER 2, IMMUTABLE) ---- */
    const DRIVER_TYPES = Object.freeze([
      "LIQUIDITY_SURGE",
      "MOMENTUM_SHIFT",
      "VOLATILITY_SPIKE",
      "VOLUME_EXPANSION",
      "SENTIMENT_REVERSAL"
    ]);

    const BLOCKER_TYPES = Object.freeze([
      "RESISTANCE_ZONE",
      "LIQUIDITY_DROUGHT",
      "MOMENTUM_EXHAUSTION",
      "VOLATILITY_COLLAPSE"
    ]);

    const GAP_TYPES = Object.freeze([
      "INFORMATION_ASYMMETRY",
      "STRUCTURAL_IMBALANCE",
      "TEMPORAL_DISLOCATION"
    ]);

    /* ---- REENTRANCY LOCK (PHASE 15.2) ---- */
    let validationEpoch = 0;

    /* ---- DOM REFERENCES ---- */
    const navEl = document.getElementById("nav");
    const statusEl = document.getElementById("status");

    /* ---- PHASE 15.1: CRYPTOGRAPHIC VALIDATION (Web Crypto API) ---- */

    /* Base64 → Uint8Array (Phase 15.2: Normalized, Strict) */
    function decodeBase64ToUint8(base64) {
      try {
        // Phase 15.2: Normalize input (trim, remove whitespace)
        if (typeof base64 !== 'string') {
          throw new Error("Not a string");
        }
        const normalized = base64.replace(/\s/g, '').trim();
        if (normalized.length === 0) {
          throw new Error("Empty Base64");
        }
        // Strict length check (Ed25519 signature = 64 bytes = 88 Base64 chars with padding)
        // Public key = 32 bytes = 44 Base64 chars
        if (normalized.length < 4) {
          throw new Error("Base64 too short");
        }
        
        const binaryString = atob(normalized);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes;
      } catch (err) {
        throw new Error("Invalid Base64");
      }
    }

    /* Import Ed25519 Public Key */
    async function importPublicKey(base64) {
      try {
        const keyData = decodeBase64ToUint8(base64);
        return await crypto.subtle.importKey(
          "raw",
          keyData,
          {
            name: "Ed25519",
            namedCurve: "Ed25519"
          },
          false,
          ["verify"]
        );
      } catch (err) {
        throw new Error("Key import failed");
      }
    }

    /* Verify Ed25519 Signature */
    async function verifySignature(payloadUint8, signatureUint8, publicKey) {
      try {
        return await crypto.subtle.verify(
          "Ed25519",
          publicKey,
          signatureUint8,
          payloadUint8
        );
      } catch (err) {
        return false;
      }
    }

    /* Time Freshness Check (Phase 15.2: Strict ISO 8601) */
    function isFresh(issuedAtISO) {
      try {
        // Type guard
        if (typeof issuedAtISO !== 'string') return false;
        
        // Strict ISO 8601 format check (basic pattern)
        const iso8601Pattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z?$/;
        if (!iso8601Pattern.test(issuedAtISO)) return false;
        
        const issued = Date.parse(issuedAtISO);
        if (isNaN(issued)) return false;
        
        // Sanity check: not too far in past/future
        const now = Date.now();
        const skew = Math.abs(now - issued);
        
        // Reject if timestamp is unreasonable (> 1 year in past/future)
        const maxReasonable = 365 * 24 * 60 * 60 * 1000;
        if (skew > maxReasonable) return false;
        
        return skew <= MAX_SKEW_MS;
      } catch (err) {
        return false;
      }
    }

    /* Unified Structural Guard (Phase 18.2: Tiers 0/1/2) */
    function unifiedStructuralGuard(packet) {
      try {
        if (!packet || typeof packet !== 'object') return false;
        if (packet.__proto__ !== Object.prototype && packet.__proto__ !== null) return false;
        
        const tier = packet.meta?.tier ?? 0;
        if (![0, 1, 2].includes(tier)) return false;
        
        if (!packet.nav || typeof packet.nav !== 'object') return false;
        if (typeof packet.nav.regime !== 'string' || !REGIMES.includes(packet.nav.regime)) return false;
        if (typeof packet.nav.risk !== 'string' || !RISK_LEVELS.includes(packet.nav.risk)) return false;
        if (typeof packet.nav.confidence !== 'string' || !CONFIDENCE_LEVELS.includes(packet.nav.confidence)) return false;
        
        if (tier === 0) {
          if (packet.nav.bias || packet.nav.stability || packet.navigator) return false;
          if (packet.meta?.signature || packet.meta?.kid) return false;
        }
        
        if (tier === 1) {
          if (!packet.meta?.signature || !packet.meta?.kid || !packet.meta?.issued_at) return false;
          if (typeof packet.nav.bias !== 'string' || !BIAS_LEVELS.includes(packet.nav.bias)) return false;
          if (typeof packet.nav.stability !== 'string' || !STABILITY_LEVELS.includes(packet.nav.stability)) return false;
          if (packet.navigator) return false;
        }
        
        if (tier === 2) {
          if (!packet.meta?.signature || !packet.meta?.kid || !packet.meta?.issued_at) return false;
          if (typeof packet.nav.bias !== 'string' || !BIAS_LEVELS.includes(packet.nav.bias)) return false;
          if (typeof packet.nav.stability !== 'string' || !STABILITY_LEVELS.includes(packet.nav.stability)) return false;
          if (!packet.navigator || typeof packet.navigator !== 'object') return false;
          
          if (!Array.isArray(packet.navigator.drivers)) return false;
          if (packet.navigator.drivers.length > 3) return false;
          for (const d of packet.navigator.drivers) {
            if (typeof d !== 'string' || !DRIVER_TYPES.includes(d)) return false;
          }
          
          if (!Array.isArray(packet.navigator.blockers)) return false;
          if (packet.navigator.blockers.length > 2) return false;
          for (const b of packet.navigator.blockers) {
            if (typeof b !== 'string' || !BLOCKER_TYPES.includes(b)) return false;
          }
          
          if (!Array.isArray(packet.navigator.gaps)) return false;
          if (packet.navigator.gaps.length > 2) return false;
          for (const g of packet.navigator.gaps) {
            if (typeof g !== 'string' || !GAP_TYPES.includes(g)) return false;
          }
        }
        
        return true;
      } catch (err) {
        return false;
      }
    }

    /* Build Global Payload (Phase 18.2: Unified for Tiers 0/1/2) */
    function buildGlobalPayload(packet) {
      try {
        const tier = packet.meta?.tier ?? 0;
        const regime = packet.nav?.regime ?? "";
        const risk = packet.nav?.risk ?? "";
        const confidence = packet.nav?.confidence ?? "";
        const bias = packet.nav?.bias ?? "";
        const stability = packet.nav?.stability ?? "";
        const drivers = packet.navigator?.drivers ? packet.navigator.drivers.join(",") : "";
        const blockers = packet.navigator?.blockers ? packet.navigator.blockers.join(",") : "";
        const gaps = packet.navigator?.gaps ? packet.navigator.gaps.join(",") : "";
        const kid = packet.meta?.kid ?? "";
        const issued_at = packet.meta?.issued_at ?? "";
        
        const payload = 
          String(tier) +
          regime +
          risk +
          confidence +
          bias +
          stability +
          drivers +
          blockers +
          gaps +
          kid +
          issued_at;
        
        const encoder = new TextEncoder();
        return encoder.encode(payload);
      } catch (err) {
        throw new Error("Global payload build failed");
      }
    }

    /* Unified Validation Pipeline (Phase 18.2: Tiers 0/1/2) */
    async function validatePacket(packet, epoch) {
      try {
        if (epoch !== validationEpoch) {
          return { tier: 0, packet: STATIC_NAV_PACKET };
        }
        
        const tier = packet.meta?.tier ?? 0;
        
        if (tier === 0) {
          if (!unifiedStructuralGuard(packet)) {
            return { tier: 0, packet: STATIC_NAV_PACKET };
          }
          return { tier: 0, packet: packet };
        }
        
        if (!unifiedStructuralGuard(packet)) {
          return { tier: 0, packet: STATIC_NAV_PACKET };
        }
        
        if (epoch !== validationEpoch) {
          return { tier: 0, packet: STATIC_NAV_PACKET };
        }
        
        const kid = packet.meta.kid;
        if (!TRUSTED_KEYS[kid]) {
          return { tier: 0, packet: STATIC_NAV_PACKET };
        }
        
        if (!isFresh(packet.meta.issued_at)) {
          return { tier: 0, packet: STATIC_NAV_PACKET };
        }
        
        const payloadBytes = buildGlobalPayload(packet);
        if (payloadBytes.length === 0 || payloadBytes.length > 2048) {
          return { tier: 0, packet: STATIC_NAV_PACKET };
        }
        
        const signatureBytes = decodeBase64ToUint8(packet.meta.signature);
        if (signatureBytes.length !== 64) {
          return { tier: 0, packet: STATIC_NAV_PACKET };
        }
        
        if (epoch !== validationEpoch) {
          return { tier: 0, packet: STATIC_NAV_PACKET };
        }
        
        const publicKey = await importPublicKey(TRUSTED_KEYS[kid]);
        
        if (epoch !== validationEpoch) {
          return { tier: 0, packet: STATIC_NAV_PACKET };
        }
        
        const valid = await verifySignature(payloadBytes, signatureBytes, publicKey);
        
        if (epoch !== validationEpoch) {
          return { tier: 0, packet: STATIC_NAV_PACKET };
        }
        
        if (!valid) {
          return { tier: 0, packet: STATIC_NAV_PACKET };
        }
        
        return { tier: tier, packet: Object.freeze({
          nav: Object.freeze({...packet.nav}),
          navigator: packet.navigator ? Object.freeze({
            drivers: Object.freeze([...packet.navigator.drivers]),
            blockers: Object.freeze([...packet.navigator.blockers]),
            gaps: Object.freeze([...packet.navigator.gaps])
          }) : undefined,
          meta: Object.freeze({...packet.meta}),
          status: packet.status ? Object.freeze({...packet.status}) : undefined
        }) };
        
      } catch (err) {
        return { tier: 0, packet: STATIC_NAV_PACKET };
      }
    }

    /* ---- PHASE 15.1: STATE SANITIZATION (Hard Reset) ---- */

    /* ---- PHASE 15.1: STATE SANITIZATION (Hard Reset) ---- */

    /* Global state holder (for potential future Tier 1 state) */
    let currentPacket = null;

    /* Sanitize to Tier 0 (Phase 18.2: Unified Downgrade) */
    function sanitizeToTier0() {
      try {
        validationEpoch++;
        
        currentPacket = null;
        
        if (window.tier1State) delete window.tier1State;
        if (window.tier2State) delete window.tier2State;
        if (window.cachedPublicKey) delete window.cachedPublicKey;
        if (window.validationBuffer) delete window.validationBuffer;

        currentPacket = Object.freeze({
          regime: STATIC_NAV_PACKET.regime,
          risk: STATIC_NAV_PACKET.risk,
          confidence: STATIC_NAV_PACKET.confidence,
          status: STATIC_NAV_PACKET.status,
          scope: STATIC_NAV_PACKET.scope
        });

        renderNAV(0, currentPacket);

      } catch (err) {
        validationEpoch++;
        currentPacket = null;
        triggerFailSafe();
      }
    }

    /* ---- PHASE 15.1: PACKET INGESTION (Validation Integration) ---- */

    /* Update State (Phase 18.2: Unified Validation Pipeline) */
    async function updateState(packet) {
      const currentEpoch = ++validationEpoch;
      
      try {
        if (!packet || typeof packet !== 'object') {
          sanitizeToTier0();
          return;
        }
        
        const result = await validatePacket(packet, currentEpoch);
        
        if (currentEpoch !== validationEpoch) {
          return;
        }
        
        currentPacket = result.packet;
        renderNAV(result.tier, currentPacket);
        
      } catch (err) {
        sanitizeToTier0();
        triggerFailSafe();
      }
    }

    /* ---- ARCHITECTURE: SANITIZE FOR TIER 0 (Deep Clone + Strip) ---- */
    function sanitizeForTier0(state) {
      try {
        // Deep clone to prevent mutation leaks
        const sanitized = {
          regime: state.regime,
          risk: state.risk,
          confidence: state.confidence,
          status: state.status,
          scope: state.scope
        };

        // Validate structure
        if (!REGIMES.includes(sanitized.regime)) {
          throw new Error("Invalid regime");
        }
        if (!RISK_LEVELS.includes(sanitized.risk)) {
          throw new Error("Invalid risk");
        }
        if (!CONFIDENCE_LEVELS.includes(sanitized.confidence)) {
          throw new Error("Invalid confidence");
        }
        if (sanitized.status !== "LIVE" && sanitized.status !== "UNKNOWN") {
          throw new Error("Invalid status");
        }
        if (sanitized.scope !== "PUBLIC" && sanitized.scope !== undefined) {
          throw new Error("Invalid scope");
        }

        return sanitized;

      } catch (err) {
        // Return fail-safe state
        return {
          regime: "UNKNOWN",
          risk: "NORMAL",
          confidence: "LOW",
          status: "UNKNOWN",
          scope: "PUBLIC"
        };
      }
    }

    /* ---- ARCHITECTURE: RENDER NAV (Phase 18.2: Unified Tier Projection) ---- */
    function renderNAV(tier, state) {
      try {
        if (tier === 2) {
          const drivers = state.navigator?.drivers?.join(", ") || "";
          const blockers = state.navigator?.blockers?.join(", ") || "";
          const gaps = state.navigator?.gaps?.join(", ") || "";
          
          const navLine =
            `[NAV] REGIME: ${state.nav.regime}` +
            ` | BIAS: ${state.nav.bias}` +
            ` | STABILITY: ${state.nav.stability}` +
            ` | RISK: ${state.nav.risk}` +
            ` | CONFIDENCE: ${state.nav.confidence}\n` +
            `[NAVIGATOR] DRIVERS: ${drivers}` +
            ` | BLOCKERS: ${blockers}` +
            ` | GAPS: ${gaps}`;
          
          navEl.textContent = navLine;
        } else if (tier === 1) {
          const navLine =
            `[NAV] REGIME: ${state.nav.regime}` +
            ` | BIAS: ${state.nav.bias}` +
            ` | STABILITY: ${state.nav.stability}` +
            ` | RISK: ${state.nav.risk}` +
            ` | CONFIDENCE: ${state.nav.confidence}`;
          
          navEl.textContent = navLine;
        } else {
          const safeState = sanitizeForTier0(state);
          
          const navLine =
            `[NAV] REGIME: ${safeState.regime}` +
            ` | RISK: ${safeState.risk}` +
            ` | CONFIDENCE: ${safeState.confidence}` +
            ` | STATUS: ${safeState.status}` +
            ` | SCOPE: ${safeState.scope}`;
          
          navEl.textContent = navLine;
        }
        
      } catch (err) {
        navEl.textContent = "[NAV] STATE: UNKNOWN";
      }
    }

    /* ---- ARCHITECTURE: RENDER STATUS (DOM Writes Only) ---- */
    function renderStatus() {
      try {
        const statusLine =
          `[STATUS] LIVE` +
          ` | SOURCE: PRESENT_STATE` +
          ` | MODE: READ_ONLY`;

        statusEl.textContent = statusLine;

      } catch (err) {
        // Fail-safe render
        statusEl.textContent = "[STATUS] OFFLINE";
      }
    }

    /* ---- FAIL-SAFE HANDLER ---- */
    function triggerFailSafe() {
      try {
        // Clear all output
        navEl.textContent = "";
        statusEl.textContent = "";

        // Render fail-safe state
        navEl.textContent = "[NAV] STATE: UNKNOWN";
        statusEl.textContent = "[STATUS] OFFLINE";

      } catch (err) {
        // Ultimate fail-safe: blank screen
        document.getElementById("terminal").innerHTML = "";
      }
    }

    /* ---- BOOT SEQUENCE (Static Render Only) ---- */
    (function init() {
      try {
        renderNAV(0, STATIC_NAV_PACKET);
        renderStatus();

      } catch (err) {
        triggerFailSafe();
      }
    })();

  </script>
</body>
</html>
